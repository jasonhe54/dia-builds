name: Create Release (Reusable)

on:
  workflow_call:
    inputs:
      build_num:
        required: true
        type: string
      short_version_str:
        required: true
        type: string
      description:
        required: false
        type: string
        default: ''
      zip_filename:
        required: true
        type: string
        description: "Just the filename (e.g., Dia-1.5.0-70554.zip)"
      is_eb_build:
        required: false
        type: boolean
        default: false
      app_name:
        required: true
        type: string
      feed_url:
        required: false
        type: string
        default: 'Manual Upload'
    secrets:
      download_url:
        required: true
        description: "Full URL to download the zip file"
    outputs:
      final_version_tag:
        value: ${{ jobs.create-release.outputs.final_version_tag }}
      asset_name:
        value: ${{ jobs.create-release.outputs.asset_name }}
      zip_filename:
        value: ${{ jobs.create-release.outputs.zip_filename }}
      status:
        value: ${{ jobs.create-release.outputs.status }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    outputs:
      final_version_tag: ${{ steps.prep.outputs.final_version_tag }}
      asset_name: ${{ steps.prep.outputs.asset_name }}
      zip_filename: ${{ steps.prep.outputs.zip_filename }}
      status: ${{ steps.create_release.outputs.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-tags: true

      - name: Prepare Version Tag and Asset Name
        id: prep
        run: |
          set -euo pipefail
          BUILD_NUM="${{ inputs.build_num }}"
          SHORT_VERSION_STR="${{ inputs.short_version_str }}"
          IS_EB="${{ inputs.is_eb_build }}"
          APP_NAME="${{ inputs.app_name }}"
          ZIP_FILENAME="${{ inputs.zip_filename }}"
          
          BASE_VERSION=$(echo "${SHORT_VERSION_STR}" | sed -E 's/ \([0-9]+\)$//' | sed 's/^/v/')

          FINAL_VERSION_TAG="${BASE_VERSION}"
          if [[ -n "${BUILD_NUM}" ]]; then
            FINAL_VERSION_TAG="${FINAL_VERSION_TAG}-${BUILD_NUM}"
          fi
          if [[ "${IS_EB}" == "true" ]]; then
            FINAL_VERSION_TAG="${FINAL_VERSION_TAG}-EB"
          fi
          
          ASSET_NAME="${APP_NAME}-${FINAL_VERSION_TAG}.zip"

          echo "final_version_tag=${FINAL_VERSION_TAG}" >> "$GITHUB_OUTPUT"
          echo "asset_name=${ASSET_NAME}" >> "$GITHUB_OUTPUT"
          echo "zip_filename=${ZIP_FILENAME}" >> "$GITHUB_OUTPUT"

      - name: Install Pandoc
        if: inputs.description != ''
        run: |
          echo "Installing pandoc..."
          sudo apt-get update
          sudo apt-get install -y pandoc
          
      - name: Format Release Notes
        id: format_notes
        if: inputs.description != ''
        env:
          RAW_NOTES: ${{ inputs.description }}
        run: |
          set -euo pipefail
          echo "Formatting release notes..."
          
          # Write the raw notes to a temp file to avoid shell interpretation issues
          echo "${RAW_NOTES}" > /tmp/raw_notes.html
          
          # Unescape HTML entities
          sed -i 's/&lt;/</g; s/&gt;/>/g; s/&#39;/'"'"'/g; s/&quot;/"/g; s/&amp;/\&/g' /tmp/raw_notes.html
          
          # Convert to markdown using pandoc
          MARKDOWN_NOTES=$(pandoc -f html -t gfm /tmp/raw_notes.html)
          
          # Write to GitHub output
          {
            echo "formatted_notes<<EOF"
            echo "$MARKDOWN_NOTES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Download Asset
        id: download
        env:
          DOWNLOAD_URL: ${{ secrets.download_url }}
        run: |
          set -euo pipefail
          echo "Downloading asset..."
          mkdir -p ./work
          DOWNLOAD_PATH="./work/asset.zip"
          
          # Download using secret URL (won't appear in logs)
          curl -L --fail --show-error --silent -o "${DOWNLOAD_PATH}" "${DOWNLOAD_URL}"
          
          if [ ! -f "${DOWNLOAD_PATH}" ]; then
            echo "::error::Failed to download asset"
            exit 1
          fi
          
          FILE_SIZE=$(stat -f%z "${DOWNLOAD_PATH}" 2>/dev/null || stat -c%s "${DOWNLOAD_PATH}" 2>/dev/null || echo "unknown")
          echo "✅ Downloaded asset (${FILE_SIZE} bytes)"
          
          echo "download_path=${DOWNLOAD_PATH}" >> "$GITHUB_OUTPUT"

      - name: Create Draft Release
        id: create_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION_TAG: ${{ steps.prep.outputs.final_version_tag }}
          ASSET_NAME: ${{ steps.prep.outputs.asset_name }}
          DOWNLOAD_PATH: ${{ steps.download.outputs.download_path }}
          ZIP_FILENAME: ${{ steps.prep.outputs.zip_filename }}
          FORMATTED_NOTES: ${{ steps.format_notes.outputs.formatted_notes }}
          ARCHIVE_SOURCE: ${{ inputs.feed_url }}
        run: |
          set -euo pipefail
          
          if git rev-parse "${VERSION_TAG}" >/dev/null 2>&1; then
            echo "✅ Git tag ${VERSION_TAG} already exists. Skipping duplicate archival."
            echo "status=SKIPPED" >> "$GITHUB_OUTPUT"
          else
            echo "Creating new Git tag and draft release for: ${VERSION_TAG}"
            
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            
            git tag "${VERSION_TAG}" -m "Archive release ${VERSION_TAG}"
            git push origin "${VERSION_TAG}"
            
            # Build release notes without exposing full URL
            if [[ "${ARCHIVE_SOURCE}" == "Manual Upload" ]]; then
              printf -v BASE_NOTES "**Original Filename:** \`%s\`\n**Source:** Manual Upload" "${ZIP_FILENAME}"
            else
              printf -v BASE_NOTES "**Original Filename:** \`%s\`\n**Source Feed:** \`%s\`" "${ZIP_FILENAME}" "${ARCHIVE_SOURCE}"
            fi
            
            if [[ -n "${FORMATTED_NOTES}" ]]; then
              printf -v FINAL_NOTES "%s\n\n---\n\n%s" "${BASE_NOTES}" "${FORMATTED_NOTES}"
            else
              FINAL_NOTES="${BASE_NOTES}"
            fi
            
            gh release create "${VERSION_TAG}" \
               --title "App Version ${VERSION_TAG}" \
               --notes "${FINAL_NOTES}" \
               --draft \
               "${DOWNLOAD_PATH}#${ASSET_NAME}"
            
            echo "New draft release created."
            echo "status=CREATED" >> "$GITHUB_OUTPUT"
          fi

      - name: Save Job Results
        if: always()
        run: |
          mkdir -p ./job-results
          cat > ./job-results/result.json <<EOF
          {
            "final_version_tag": "${{ steps.prep.outputs.final_version_tag }}",
            "asset_name": "${{ steps.prep.outputs.asset_name }}",
            "zip_filename": "${{ steps.prep.outputs.zip_filename }}",
            "status": "${{ steps.create_release.outputs.status }}"
          }
          EOF

      - name: Upload Job Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: job-result-${{ inputs.build_num }}
          path: ./job-results/result.json
          retention-days: 1
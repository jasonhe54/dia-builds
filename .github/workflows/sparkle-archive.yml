name: Archive Releases from Sparkle Feed

on:
  workflow_dispatch:
    inputs:
      feed_type:
        description: "Which feed to parse for new builds?"
        required: true
        type: choice
        options:
        - Early Bird
        - Release
      app_name:
        description: "The name of the app (e.g., Dia) for the asset filename"
        required: true
        type: string
        default: "Dia"

concurrency:
  group: ${{ github.workflow }}-${{ inputs.feed_type }}
  cancel-in-progress: true

jobs:
  parse-feed:
    name: Parse Sparkle Feed
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.parse.outputs.matrix }}
      is_eb_build: ${{ steps.prep_env.outputs.is_eb_build }}
      feed_url: ${{ steps.prep_env.outputs.feed_url }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare Environment
        id: prep_env
        env:
          EB_URL: ${{ secrets.SPARKLE_FEED_URL_EB }}
          RELEASE_URL: ${{ secrets.SPARKLE_FEED_URL_RELEASE }}
        run: |
          set -euo pipefail
          if [[ "${{ inputs.feed_type }}" == "Early Bird" ]]; then
            echo "Setting environment for Early Bird feed..."
            echo "is_eb_build=true" >> "$GITHUB_OUTPUT"
            echo "feed_url=${EB_URL}" >> "$GITHUB_OUTPUT"
          else
            echo "Setting environment for Release feed..."
            echo "is_eb_build=false" >> "$GITHUB_OUTPUT"
            echo "feed_url=${RELEASE_URL}" >> "$GITHUB_OUTPUT"
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Install Python XML requirement
        run: |
          pip install lxml 

      - name: Fetch, Clean, and Parse Feed
        id: parse
        env:
          FEED_URL: ${{ steps.prep_env.outputs.feed_url }}
        run: |
          set -euo pipefail
          echo "Fetching feed..."
          
          # Fetch the feed and clean up the malformed xmlns attributes
          curl -L --fail --show-error "${FEED_URL}" | \
            sed 's/xmlns:_xmlns="xmlns" //' | \
            sed 's/_xmlns:/xmlns:/g' > feed.xml
          
          echo "Contents of cleaned feed (first 50 lines):"
          head -n 50 feed.xml
          
          echo "Parsing cleaned feed with Python script..."
          
          # Make the script executable
          chmod +x ./scripts/parse_feed.py
          
          # Run the python script and capture its stdout
          JSON_MATRIX=$(python3 ./scripts/parse_feed.py feed.xml)
          
          if [[ -z "${JSON_MATRIX}" || "${JSON_MATRIX}" == "[]" ]]; then
            echo "::error::No <item> elements found in the XML feed. Python script failed to parse."
            echo "Feed content:"
            cat feed.xml
            exit 1
          fi
          
          echo "Found items: ${JSON_MATRIX}"
          echo "matrix=${JSON_MATRIX}" >> "$GITHUB_OUTPUT"

  archive-release:
    name: Archive Release (${{ matrix.item.build_num }})
    needs: parse-feed
    if: needs.parse-feed.outputs.matrix != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    strategy:
      fail-fast: false
      matrix:
        item: ${{ fromJson(needs.parse-feed.outputs.matrix) }}
    
    outputs:
      final_version_tag: ${{ steps.prep.outputs.final_version_tag }}
      asset_name: ${{ steps.prep.outputs.asset_name }}
      zip_filename: ${{ steps.prep.outputs.zip_filename }}
      status: ${{ steps.create_release.outputs.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-tags: true

      - name: Prepare Version Tag and Asset Name
        id: prep
        run: |
          set -euo pipefail
          BUILD_NUM="${{ matrix.item.build_num }}"
          SHORT_VERSION_STR="${{ matrix.item.short_version_str }}"
          IS_EB="${{ needs.parse-feed.outputs.is_eb_build }}"
          APP_NAME="${{ inputs.app_name }}"
          ZIP_URL="${{ matrix.item.zip_url }}"
          
          BASE_VERSION=$(echo "${SHORT_VERSION_STR}" | sed -E 's/ \([0-9]+\)$//' | sed 's/^/v/')

          FINAL_VERSION_TAG="${BASE_VERSION}"
          if [[ -n "${BUILD_NUM}" ]]; then
            FINAL_VERSION_TAG="${FINAL_VERSION_TAG}-${BUILD_NUM}"
          fi
          if [[ "${IS_EB}" == "true" ]]; then
            FINAL_VERSION_TAG="${FINAL_VERSION_TAG}-EB"
          fi
          
          ASSET_NAME="${APP_NAME}-${FINAL_VERSION_TAG}.zip"
          ZIP_FILENAME=$(basename "${ZIP_URL}")

          echo "final_version_tag=${FINAL_VERSION_TAG}" >> "$GITHUB_OUTPUT"
          echo "asset_name=${ASSET_NAME}" >> "$GITHUB_OUTPUT"
          echo "zip_filename=${ZIP_FILENAME}" >> "$GITHUB_OUTPUT"
          echo "zip_url=${ZIP_URL}" >> "$GITHUB_OUTPUT"

      - name: Install Pandoc
        if: matrix.item.description != ''
        run: |
          echo "Installing pandoc..."
          sudo apt-get update
          sudo apt-get install -y pandoc
          
      - name: Format Release Notes
        id: format_notes
        if: matrix.item.description != ''
        run: |
          set -euo pipefail
          echo "Formatting release notes..."
          RAW_NOTES='${{ matrix.item.description }}'
          
          UNESCAPED_NOTES=$(echo "${RAW_NOTES}" | \
            sed 's/&lt;/</g' | \
            sed 's/&gt;/>/g' | \
            sed 's/&#39;/'"'"'/g' | \
            sed 's/&quot;/"/g' | \
            sed 's/&amp;/\&/g')
          
          MARKDOWN_NOTES=$(echo "${UNESCAPED_NOTES}" | pandoc -f html -t gfm)
          
          echo "formatted_notes<<EOF" >> "$GITHUB_OUTPUT"
          echo "$MARKDOWN_NOTES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Download Asset
        id: download
        run: |
          set -euo pipefail
          mkdir -p ./work
          DOWNLOAD_PATH="./work/asset.zip"
          curl -L --fail --show-error -o "${DOWNLOAD_PATH}" "${{ steps.prep.outputs.zip_url }}"
          echo "download_path=${DOWNLOAD_PATH}" >> "$GITHUB_OUTPUT"

      - name: Create Draft Release
        id: create_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION_TAG: ${{ steps.prep.outputs.final_version_tag }}
          ASSET_NAME: ${{ steps.prep.outputs.asset_name }}
          DOWNLOAD_PATH: ${{ steps.download.outputs.download_path }}
          ZIP_URL: ${{ steps.prep.outputs.zip_url }}
          FORMATTED_NOTES: ${{ steps.format_notes.outputs.formatted_notes }}
          ARCHIVE_SOURCE_URL: ${{ needs.parse-feed.outputs.feed_url }}
        run: |
          set -euo pipefail
          
          if git rev-parse "${VERSION_TAG}" >/dev/null 2>&1; then
            echo "âœ… Git tag ${VERSION_TAG} already exists. Skipping duplicate archival."
            echo "status=SKIPPED" >> "$GITHUB_OUTPUT"
          else
            echo "Creating new Git tag and draft release for: ${VERSION_TAG}"
            
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            
            git tag "${VERSION_TAG}" -m "Archive release ${VERSION_TAG}"
            git push origin "${VERSION_TAG}"
            
            printf -v BASE_NOTES "Archived from: \`%s\`\nSource Feed: \`%s\`" "${ZIP_URL}" "${ARCHIVE_SOURCE_URL}"
            if [[ -n "${FORMATTED_NOTES}" ]]; then
              printf -v FINAL_NOTES "%s\n\n---\n\n%s" "${BASE_NOTES}" "${FORMATTED_NOTES}"
            else
              FINAL_NOTES="${BASE_NOTES}"
            fi
            
            gh release create "${VERSION_TAG}" \
               --title "App Version ${VERSION_TAG}" \
               --notes "${FINAL_NOTES}" \
               --draft \
               "${DOWNLOAD_PATH}#${ASSET_NAME}"
            
            echo "New draft release created."
            echo "status=CREATED" >> "$GITHUB_OUTPUT"
          fi

  job-summary:
    name: Write Summary
    runs-on: ubuntu-latest
    needs: archive-release
    if: always()

    steps:
      - name: Install JQ
        run: sudo apt-get install -y jq
        
      - name: Write Job Summary
        run: |
          set -euo pipefail
          echo "## ðŸ“¦ Batch Archive Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Version Tag | Asset Name | Source Filename | Status |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY
          
          # Convert the 'needs' context into a JSON object
          echo '${{ toJSON(needs.archive-release.outputs) }}' > outputs.json
          
          # Debug: Show what the outputs object looks like
          echo "--- Matrix Outputs JSON ---"
          cat outputs.json
          echo "--- End Outputs JSON ---"

          # Check if the outputs object is empty
          if [[ $(cat outputs.json | jq 'length') -eq 0 ]]; then
            echo "| *No archive jobs were run or data was unavailable.* | | | |" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # Format the single object output (GitHub Actions matrix outputs only give you one job's output)
          jq -r '"| `" + .final_version_tag + "` | `" + .asset_name + "` | `" + .zip_filename + "` | " + .status + " |"' outputs.json >> $GITHUB_STEP_SUMMARY